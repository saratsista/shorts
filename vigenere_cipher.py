#! /usr/bin/python

import itertools  # import itertools module to use iterator functions


# This function is a generator which generates each alphabet of input key word for each letter in input text
def counter(key, inputLen):		# Takes the input key & length of input text as parameters
  c = itertools.cycle(key)		# iterate the key in a cyclic way infinitely. An iterator object is created and stored in 'c'
  s = 1 						# This variable helps to iterate the key along the length of the input text & not more
  while s<= inputLen:			# while 's' is less than the length of input text...
    yield next(c)				# ...yield the next value of the iterator
    s += 1						# Increment the value of s by 1
    
    

''' This function calculates the encrypted letter for each tuple in keyTxtMap based on vigenere square 
  	  Note: Each input tuple signifies the corresponding row and column we have to access in vigenere square to find out the encrypted
  	        letter.
  	  The 'viglet' is calculated as follows
      An element in vigenere square can be accessed as sqr[i][j] where 0 <=i,j<= 25.
      since the vignere square is filled with A-Z and not 0-25, only way is to find the ascii value of the character in row and 
      ascii value of character in column. As the ascii values range from 65-91 and we need i and j to be 0-25, we subtract 65 from
      ascii value of each element per tuple of list 'keyTxtMap'. Each element in tuple can be accessed as tuple[0][0] for 1st element
      and tuple[0][1] for 2nd element. Finally we have, for sqr[i][j],
      i = ord(keyTxtMapElement[0][0]) - 65  and
      j = ord(keyTxtMapElement[0][1]) - 65
      
  '''    	
def vigEncrypt(*keyTxtMapElement): 			# Take each tuple in the list 'keyTxtMap' as input. '*' says that input is either tuple or list. 
  sqr = vigSquare()							# construct the vigenere square and store it in 'sqr' variable. vigSquare() constructs the square
  viglet = sqr[ord(keyTxtMapElement[0][0]) - 65][ord(keyTxtMapElement[0][1]) - 65]	# calculate the  letter in vigener square for each tuple
  return viglet								# return the letter found for corresponding tuple in vigenere square
  
  
'''This function constructs the vigenere square:
	itertools.dropwhile(func,iter) drops the value given by iterator if function holds true for it
	x constructs a group of lists, with each list missing one alphabet form A-Z starting from A
	y constructs a group of lists, with each list missing one alphabet from A-Z starting from Z
	Since y has alphabets in reverse order in each list, we reverse y and store it in 'z'
	we add x and z and store the result in 'vigSqr'
	zip(x,z) function adds the first element in x( which is a list), to 1st element in z (which is also a list), resulting in appending
	of list1 in x and list1 in z. This continues until all lists in x are appended with corresponding lists in z
'''
def vigSquare():
  x = ([[chr(j) for j in itertools.dropwhile((lambda u: u!=j), range(65,91))] for j in range(65,91)])
  y = [[chr(s) for s in itertools.dropwhile(lambda v: v>s, reversed(range(65,91))) if chr(s) not in x] for s in range(65,91)]
  z = [list[::-1] for list in y]
  vigSqr = [i+j for i,j in zip(x,z)]
  return vigSqr
 
 
#This function encompasses the code for vigenere cipher 
def vigenere(ipText,k):					# Takes the input key and input text as parameters
  keyItr = counter(k,len(ipText)) 		# call the generator function 'counter' and store the generator object in 'keyItr'
  keyTxtMap = [(char,next(keyItr)) for char in ipText] # Construct a list of tuples, where the 1st element is character from the input text and 2nd element is iterator value generated by 'counter', which is char in input key
  print keyTxtMap						# print the resulting mapping
  print len(keyTxtMap)					# print the length of list of tuples
  encTxt = map(vigEncrypt,keyTxtMap)	# using map function, each tuple of list 'keyTxtMap' is sent as input to 'vigEncrypt' function which finds the corresponding encrypted letter form vigenere square. i.e., map applies func to each element in list
  return encTxt							# return the list of encrypted letters.
  
  
def main():
  input_text = raw_input('Enter text to be encrypted\n')
  input_text = [char for char in input_text.upper() if char!=' ']
  key = raw_input('Enter a key word\n')
  key = list(key.upper())
  encrypted_text = vigenere(input_text,key)
  print ''.join(encrypted_text)      
  
  

if __name__ == '__main__':
  main()
  

  
